---
layout: post
title: winapi 0.3
published: false
---

For over a year people have been wondering when the next version of winapi would be published, and today I am happy to announce that winapi 0.3 has finally been [published to crates.io](https://crates.io/crates/winapi)! This new version has a lot of changes so this post will go over them and any changes that will be necessary in your own code when migrating to this new version.

## COM interfaces

All COM interfaces now implement the `Interface` trait, which will allow better `ComPtr` abstractions. Currently this trait exposes a single method which returns the IID of the interface, essential for `QueryInterface` wrappers. For example, to get the IID of the `IUnknown` interface, call `IUnknown::uuidof()`.

## The `-sys` crates are dead. Long live the `winapi` behemoth.

In previous versions of `winapi`, function bindings were separated into their own independent crates based on which import library contained those symbols. For example, the `MessageBoxW` function is exported from `user32.lib`, and was thus bound in the `user32-sys` crate.

In 0.3, this is no longer true: the `winapi` crate contains all types, constants, macros, *and* functions. As such, dependencies on all `-sys` crates in the winapi family should be removed, and all imports updated to point towards `winapi` itself.

## Items are now organised into modules.

Binding items in `winapi` were previously not organised into modules. This allowed you to use a type, or constant without having to consider where it was defined. If C code or documentation mentioned `HWND`, then it was available as `winapi::HWND`, irrespective of the C header required.

In 0.3, all items are organised into modules based on the Windows SDK header file that defines them. \[[†](#fn†)] `HWND` is now located at `shared::windef::HWND`. To continue the example of `MessageBoxW`, it is defined by `winuser.h`. This means it can now be found in the `um::winuser` module.

You can determine where an item (or the module that corresponds to a particular header) is located by searching the [online `winapi` 0.3 documentation]. Most translated headers will be in the `um` (user-mode) top-level module, items shared between user- and kernel-mode code in the `shared` module, Visual C++-specific items in the `vc` module, and WinRT-related items in the `winrt` module.

If given a choice between using names from both `shared` and `um` (as the latter re-exports items from the former), and you are not writing code intended to run in the kernel (*i.e.* device drivers), stick to `um`. There is no difference between the two, but using the `um` modules better matches the conventions of writing user-mode code.

Note: if you are familiar with the file structure of the Windows SDK headers, `winapi` now directly mirrors that.

[online `winapi` 0.3 documentation]: https://docs.rs/winapi/0.3/x86_64-pc-windows-msvc/winapi/

## Modules gated on feature flags

All binding modules are gated behind Cargo feature flags. This means that in order to access the contents of a module, you must first enable the corresponding feature flag on the `winapi` crate. For example, to use `MessageBoxW` in the `um::winuser` module, you must enable the `winuser` feature.

Note that enabling a module *also* enables any modules it depends on for types. For example, `MessageBoxW`'s definition requires `HWND`. As a result, enabling the `winuser` feature *also* enables (among others) the `windef` feature, so that `HWND` is defined.

Features also control which DLLs will be linked. Enabling `winuser` automatically causes your program to be linked against the `User32` library.

There is also an `everything` feature that enables all other feature gates. Enabling everything will adversely affect build times. \[[‡](#fn‡)]

## Enumerations

Previously, each `enum` was translated to a "newtype" structure. For example, the definition of `POINTER_INPUT_TYPE` in `winapi` 0.2 was equivalent to:

```rust
pub struct POINTER_INPUT_TYPE(pub u32);
pub const PT_POINTER: POINTER_INPUT_TYPE = POINTER_INPUT_TYPE(0x00000001);
pub const PT_TOUCH: POINTER_INPUT_TYPE = POINTER_INPUT_TYPE(0x00000002);
pub const PT_PEN: POINTER_INPUT_TYPE = POINTER_INPUT_TYPE(0x00000003);
pub const PT_MOUSE: POINTER_INPUT_TYPE = POINTER_INPUT_TYPE(0x00000004);
pub const PT_TOUCHPAD: POINTER_INPUT_TYPE = POINTER_INPUT_TYPE(0x00000005);
```

For `winapi` 0.3, enumerations are instead type aliases to the underlying integer type. The equivalent to the above in 0.3 is:

```rust
pub type POINTER_INPUT_TYPE = u32;
pub const PT_POINTER: POINTER_INPUT_TYPE = 0x00000001;
pub const PT_TOUCH: POINTER_INPUT_TYPE = 0x00000002;
pub const PT_PEN: POINTER_INPUT_TYPE = 0x00000003;
pub const PT_MOUSE: POINTER_INPUT_TYPE = 0x00000004;
pub const PT_TOUCHPAD: POINTER_INPUT_TYPE = 0x00000005;
```

## Standard library support and `c_void`.

`winapi` now defaults to *not* linking against the standard library. There is only one situation in which this will be a problem: when you wish to use `winapi` definitions with other code that uses the `c_void` type.

`winapi` defines a number of C-compatible types in the top-level `ctypes` module. All of these are aliases to the "real" type (*e.g.* `type c_char = i8;`). The exception is `c_void` which does not have a single, corresponding Rust type. As such, by default, `winapi` defines its own `c_void` type.

However, this `c_void` will not be compatible with `c_void` as used by any other code, unless that code is specifically using `winapi`'s type. This can be fixed by enabling the `std` feature, which causes `winapi::ctypes::c_void` to instead alias to `std::os::raw::c_void`.

## Example

Consider the following example program using `winapi` 0.2.

```rust
//! Add the following to `Cargo.toml`:
//!
//! ```cargo
//! [dependencies]
//! winapi = "0.2"
//! user32-sys = "0.2"
//! ```

extern crate winapi;
extern crate user32;
use std::io::Error;

fn print_message(msg: &str) -> Result<i32, Error> {
    use std::ffi::OsStr;
    use std::iter::once;
    use std::os::windows::ffi::OsStrExt;
    use std::ptr::null_mut;
    use winapi::MB_OK;
    use user32::MessageBoxW;
    let wide: Vec<u16> = OsStr::new(msg).encode_wide().chain(once(0)).collect();
    let ret = unsafe {
        MessageBoxW(null_mut(), wide.as_ptr(), wide.as_ptr(), MB_OK)
    };
    if ret == 0 { Err(Error::last_os_error()) }
    else { Ok(ret) }
}

fn main() {
    print_message("Hello, world!").unwrap();
}
```

It would be modified as follows for `winapi` 0.3.

```rust
//! Add the following to `Cargo.toml`:
//!
//! ```cargo
//! [dependencies.winapi]
//! version = "0.3"
//! features = ["winuser"] # enable the `um::winuser` module.
//!
//! # No dependency on `user32-sys`.
//! ```

extern crate winapi;
// No `extern crate user32;`.
use std::io::Error;

fn print_message(msg: &str) -> Result<i32, Error> {
    use std::ffi::OsStr;
    use std::iter::once;
    use std::os::windows::ffi::OsStrExt;
    use std::ptr::null_mut;
    // `MB_OK` and `MessageBoxW` are in a module.
    use winapi::um::winuser::{MB_OK, MessageBoxW};
    let wide: Vec<u16> = OsStr::new(msg).encode_wide().chain(once(0)).collect();
    let ret = unsafe {
        MessageBoxW(null_mut(), wide.as_ptr(), wide.as_ptr(), MB_OK)
    };
    if ret == 0 { Err(Error::last_os_error()) }
    else { Ok(ret) }
}

fn main() {
    print_message("Hello, world!").unwrap();
}
```

---

<a name="fn†"></a>
\[†]: This is due to the existence of duplicate, non-compatible definitions in the Windows SDK. The SDK gets around this via abuse of the C pre-processor to redefine names based on the order in which header files are included.

<a name="fn‡"></a>
\[‡]: You will not just have time to make a cup of coffee. You will have time to fly to the coffee belt, harvest the beans, fly back, roast them, grind them, and *then* make a cup of coffee. It will still be faster than compiling `winapi = "0.2"` though.
